-- main data types:
42b -- Byte
42 -- Int
1/2 -- Rational
1.0 -- Real
"hello" -- String
'a' -- Char
true -- Bool
() -- Unit

-- Files are composed of declarations at the top level. In the notebook 
-- or repl, you can use expressions at the top level. You can think of 
-- this as a shorthand for `def main args = <expr>`. In files, the main 
-- function must be defined explicitly:
def main () ! IO =
  println "Hello, world!"

-- Bindings are immutable by default.
def x = 1

-- pattern bindings at the top level must be irrefutable
def [a, b, c] = [1, 2, 3]
-- > ERROR: Pattern match is not exhaustive

def (a, b, c) = (1, 2, 3) -- this is fine because the pattern is exhaustive
-- > a = 1, b = 2, c = 3

-- ints
1

-- booleans
true

-- Binary operators
1 + 2 * 3^2 - 4 / 5 % 10

-- Unary operators
-1
-- > -1

not true
-- > false

-- Boolean operators
true and false or true
-- > true

-- Comparison
1 < 2 and 2 <= 3 and 3 > 2 and 3 >= 2 and 2 = 2 and 2 != 3

-- if-then-else
if 1 < 2 then 1 else 2

-- let-in
let x = 1 in x + 1

-- function definition
def f x = x + 1

-- this is equivalent to
def f = \x -> x + 1

-- function expression
let f x = x + 1 in f 1

-- function application
f 1

-- closure
\x -> x + 1

-- closure application
(\x -> x + 1) 1

-- nested let
let x = 1 in let y = 2 in x + y

-- recursion
def fib n = 
  if n <= 1 then n 
  else fib (n - 1) + fib (n - 2) 

def gcd a b = 
  if b = 0 then a 
  else gcd b (a % b)

-- with type annotations
def gcd (a : Int) (b : Int) : Int =
  if b = 0 then a 
  else gcd b (a % b)

def fib (n : Int) : Int =
  if n <= 1 then n 
  else fib (n - 1) + fib (n - 2)

def lcm (a : Int) (b : Int) : Int =
  a * b / gcd a b

def lcm a b = a * b / gcd a b

-- tail recursive fib
def fib n = 
  let loop a b i = 
    if i = 0 then a 
    else loop b (a + b) (i - 1)
  in loop 0 1 n

-- pattern match
def fib n = 
  match n
  | 0 -> 0
  | 1 -> 1
  | n -> fib (n - 1) + fib (n - 2)

def fact n =
  let loop acc n =
    if n = 0 then acc
    else loop (acc * n) (n - 1)
  in loop 1 n

def map a b. (f : a -> b) (xs : [a]) : [b] =
  match xs with
  | [] -> []
  | (x::xs) -> f x :: map f xs

-- possible uncurried version of sigs
def map : a b. [a] (a -> b) -> [b]
  | [] f -> []
  | (x::xs) f -> f x :: map f xs

pub def map f xs = match xs with
  [] -> []
  (x::xs) -> f x :: map f xs

def map f xs =
  match xs with
  | [] -> []
  | (x::xs) -> f x :: map f xs

-- or
pub def map : a b. (a -> b) -> [a] -> [b]
  f [] -> []
  f (x::xs) -> f x :: map f xs

@pub
map : a b. (a -> b) -> [a] -> [b]
map f [] = []
map f (x::xs) = f x :: map f xs

def foldl f acc xs =
  match xs with
  | [] -> acc
  | (x :: xs) -> foldl f (f acc x) xs

def foldl = \f acc xs ->
  match xs with
  | [] -> acc
  | (x :: xs) -> foldl f (f acc x) xs

def foldl : a b. (a -> b -> a) -> a -> [b] -> a
  | f acc [] = acc
  | f acc (x::xs) = foldl f (f acc x) xs

def foldl : a b e. (a -> b -> a) -> a -> [b] -> a
  | f acc []      = acc
  | f acc (x::xs) = foldl f (f acc x) xs

def foldl : (a -> b -> a) -> a -> [b] -> a
  | f acc []      = acc
  | f acc (x::xs) = foldl f (f acc x) xs

def foldl a b. (f : a -> b -> a) (acc: a) (xs : [b]) : a =
  match xs with
  | [] -> acc
  | (x :: xs) -> foldl f (f acc x) xs

def foldl f acc xs = match xs with
  [] -> acc
  (x::xs) -> foldl f (f acc x) xs

def foldr f acc xs = match xs with
  | [] -> acc
  | (x::xs) -> f x (foldr f acc xs)

def foldr a b. (f : a -> b -> b) (acc : b) (xs : [a]) : b =
  match xs with
  | [] -> acc
  | (x :: xs) -> f x (foldr f acc xs)

def foldr : a b. (a -> b -> b) -> b -> [a] -> b 
  | f acc [] = acc
  | f acc (x::xs) = f x (foldr f acc xs) 

def binary_search : a. (a -> Ordering) -> [a] -> a -> Option Int
  | cmp xs x -> 
    let loop l r =
      if l > r then None
      else
        let m = (l + r) / 2
        match cmp x (xs !! m) with
        | Ordering.Eq -> Some m
        | Ordering.Lt -> loop l (m - 1)
        | Ordering.Gt -> loop (m + 1) r
    in loop 0 (len xs - 1)

-- type alias
type Point = (Int, Int)

-- records
data Person = { name : String, age : Int }
def p = { name = "Alice", age = 30 }

-- records with public fields
@pub data Person = { @pub name : String, @pub age : Int }

-- functional update
def p = { name = "Alice", age = 30 }
def p' = { p with age = 31 }

-- sum types
data Option a = None | Some a

-- sum type with effectful constructors
data Foo a e = Bar a | Baz (a -> a)

data List a = Empty | Pair a (List a)

data List a = [] | a :: List a

data NonEmptyList a = NonEmpty a (List a)

-- with infix constructors
data NomEmptyList a = a :| List a

def (|>) : a b. a -> (a -> b) -> b
  | x |> f = f x

-- methods with pipe
[1, 2, 3]
  |> into_iter
  |> map (+ 1)
  |> filter ((= 0) ∘ (% 2))

-- into_iter postfix operator
[1, 2, 3]!
  |> map (+ 1)
  |> filter ((= 0) ∘ (% 2))
  |> reduce (+)

-- iterator comprehensions
[for x in [1, 2, 3] if x % 2 = 0]

-- type classes
class Eq a where
  def eq : a -> a -> Bool

instance Eq Int where
  def eq = prim_int_eq

instance Eq (Option a) where
  def eq : Eq a => Option a -> Option a -> Bool
    | None None = true 
    | (Some x) (Some y) = eq x y
    |  _ _ = false

class Ord a <: Eq + PartialOrd where
  def compare : a -> a -> Ordering

class Add a b where
  def data Output = a
  def (+) : a -> b -> Output

data Ordering = Lt | Eq | Gt

class Eq a where
  def (=) : a -> a -> Bool

class PartialOrd a where
  def partial_compare : a -> a -> Option Ordering

  def (<) (x : a) (y : a) : Bool = 
    match partial_compare x y with
    | Some Lt -> true
    | _ -> false

  def (<=) (x : a) (y : a) : Bool =
    match partial_compare x y with
    | Some Lt -> true
    | Some Eq -> true
    | _ -> false

  def (>) (x : a) (y : a) : Bool =
    match partial_compare x y with
    | Some Gt -> true
    | _ -> false

  def (>=) (x : a) (y : a) : Bool =
    match partial_compare x y with
    | Some Gt -> true
    | Some Eq -> true
    | _ -> false

class (Eq a, PartialOrd a) => Ord a where
  def compare : a -> a -> Ordering
  def (<) : a -> a -> Bool
  def (<=) : a -> a -> Bool
  def (>) : a -> a -> Bool
  def (>=) : a -> a -> Bool


